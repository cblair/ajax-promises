{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/ajax-promises.js"
  ],
  "names": [],
  "mappings": "AAAA;YCAA,SAAS,YAAW,EAAS,GACzB,GAAM,GAAU,EAAQ,WACxB,KAAI,GAAI,KAAU,GACd,EAAQ,iBAAiB,EAAQ,EAAQ,IAIjD,QAAS,eAAc,EAAK,GACxB,GAAM,GAAU,GAAI,gBACd,EAAS,EAAQ,QAAU,KAGjC,OAFA,GAAQ,KAAK,EAAQ,GACrB,WAAW,EAAS,GACb,EAGX,QAAS,aAAY,EAAS,EAAS,GACnC,EAAQ,OAAS,WACb,GAAG,EAAQ,QAAU,KAAO,EAAQ,OAAS,IACzC,EAAQ,EAAQ,kBACb,CACH,GAAM,GAAQ,MAAM,EAAQ,YAAc,iCAC1C,GAAM,OAAS,EAAQ,OACvB,EAAO,KAGf,EAAQ,QAAU,SAAS,GACvB,EAAO,IAIf,QAAS,aAAY,GACjB,GAAM,MADiB,EAAA,SAGf,GACJ,GAAM,GAAQ,MAAM,QAAQ,EAAK,IAAQ,EAAK,IAAQ,EAAK,GAC3D,GAAM,QAAQ,SAAA,GACV,EAAQ,KAAK,mBAAmB,GAAO,IAAM,mBAAmB,MAHxE,KAAI,GAAI,KAAO,GAAM,EAAb,EAMR,OAAO,GAAQ,KAAK,KAGxB,QAAS,MAAK,EAAK,GAQf,QAAS,GAAQ,GACb,MAAO,IAAI,SAAQ,SAAC,EAAS,GACzB,EAAW,GAAY,EACvB,EAAQ,mBAAqB,WACtB,KAAK,YAAc,KAAK,kBACvB,EAAS,EAAQ,0BAGzB,EAAQ,KAAK,GACb,EAAQ,MAAM,KAItB,QAAS,GAAK,GACV,MAAO,IAAI,SAAQ,SAAC,EAAS,GACzB,EAAQ,KAAK,KAAK,OACb,KAAK,GAAY,GACjB,MAAM,KAxBnB,GAAM,GAAU,cAAc,EAAK,GAE7B,EAAU,GAAI,SAAQ,SAAC,EAAS,GAClC,YAAY,EAAS,EAAS,GAC9B,EAAQ,KAAK,EAAQ,OA2BzB,OAHA,GAAQ,KAAO,EACf,EAAQ,QAAU,EAEX,EAMX,GAAM,eAIF,YAAA,YAKA,IATiB,SASb,GAAmB,GAAd,GAAc,UAAA,OAAA,GAAA,SAAA,UAAA,GAAA,UAAA,KAGnB,OAFA,GAAQ,OAAS,MACjB,EAAQ,KAAO,KACR,KAAK,EAAK,IAMrB,KAlBiB,SAkBZ,EAAK,GAAoB,GAAd,GAAc,UAAA,OAAA,GAAA,SAAA,UAAA,GAAA,UAAA,KAK1B,OAJA,GAAQ,OAAS,OACjB,EAAQ,QAAU,EAAQ,YAC1B,EAAQ,QAAQ,gBAAkB,mDAClC,EAAQ,KAAO,YAAY,GACpB,KAAK,EAAK,IAMrB,SA7BiB,SA6BR,EAAK,GAAoB,GAAd,GAAc,UAAA,OAAA,GAAA,SAAA,UAAA,GAAA,UAAA,KAK9B,OAJA,GAAQ,OAAS,OACjB,EAAQ,QAAU,EAAQ,YAC1B,EAAQ,QAAQ,gBAAkB,kCAClC,EAAQ,KAAO,KAAK,UAAU,GACvB,KAAK,EAAK,IAQrB,KA1CiB,SA0CZ,GAAmB,GAAd,GAAc,UAAA,OAAA,GAAA,SAAA,UAAA,GAAA,UAAA,KAGpB,OAFA,GAAQ,OAAS,OACjB,EAAQ,KAAO,KACR,KAAK,EAAK,GAAS,WAKlC,QAAO,QAAU",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "function addHeaders(request, options) {\n    const headers = options.headers || {};\n    for(let header in headers) {\n        request.setRequestHeader(header, headers[header]);\n    }\n}\n\nfunction createRequest(url, options) {\n    const request = new XMLHttpRequest();\n    const method = options.method || 'GET';\n    request.open(method, url);\n    addHeaders(request, options);\n    return request;\n}\n\nfunction addHandlers(request, resolve, reject) {\n    request.onload = function() {\n        if(request.status >= 200 && request.status < 400) {\n            resolve(request.responseText);\n        } else {\n            const error = Error(request.statusText || 'Unknown failure; possibly CORS');\n            error.status = request.status;\n            reject(error);\n        }\n    };\n    request.onerror = function(e) {\n        reject(e);\n    };\n}\n\nfunction encodeQuery(data) {\n    const urlData = [];\n\n    for(let key in data) {\n        const value = Array.isArray(data[key]) ? data[key] : [data[key]];\n        value.forEach(v => {\n            urlData.push(encodeURIComponent(key) + '=' + encodeURIComponent(v));\n        });\n    }\n    return urlData.join('&');\n}\n\nfunction load(url, options) {\n    const request = createRequest(url, options);\n\n    const promise = new Promise((resolve, reject) => {\n        addHandlers(request, resolve, reject);\n        request.send(options.data);\n    });\n\n    function headers(executor) {\n        return new Promise((resolve, reject) => {\n            executor = executor || resolve;\n            request.onreadystatechange = function() {\n                if(this.readyState == this.HEADERS_RECEIVED) {\n                    executor(request.getAllResponseHeaders());\n                }\n            };\n            promise.then(resolve);\n            promise.catch(reject);\n        });\n    }\n\n    function json(executor) {\n        return new Promise((resolve, reject) => {\n            promise.then(JSON.parse)\n                .then(executor || resolve)\n                .catch(reject);\n        });\n    }\n\n    promise.json = json;\n    promise.headers = headers;\n\n    return promise;\n}\n\n/**\n * XMLHttpRequest to Promise wrapper, with JSON functionality built in.\n */\nconst ajaxPromises = {\n    /**\n     * URL encode data for use as query string.\n     */\n    encodeQuery,\n\n    /**\n     * GET url with options.\n     */\n    get(url, options = {}) {\n        options.method = 'GET';\n        options.data = null;\n        return load(url, options);\n    },\n\n    /**\n     * POST data to url (with options) as an URL-encoded form. This usually works anywhere, with anything.\n     */\n    post(url, data, options = {}) {\n        options.method = 'POST';\n        options.headers = options.headers || {};\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        options.data = encodeQuery(data);\n        return load(url, options);\n    },\n\n    /**\n     * POST raw JSON to url (with options).\n     */\n    postJson(url, data, options = {}) {\n        options.method = 'POST';\n        options.headers = options.headers || {};\n        options.headers['Content-Type'] = 'application/json; charset=UTF-8';\n        options.data = JSON.stringify(data);\n        return load(url, options);\n    },\n\n    /**\n     * HEAD url with options.\n     *\n     * @returns {Object} the headers returned from the URL.\n     */\n    head(url, options = {}) {\n        options.method = 'HEAD';\n        options.data = null;\n        return load(url, options).headers();\n    },\n\n};\n\nmodule.exports = ajaxPromises;\n"
  ]
}